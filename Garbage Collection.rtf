{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf400
{\fonttbl\f0\froman\fcharset0 TimesNewRomanPSMT;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\qj\partightenfactor0

\f0\b\fs42\fsmilli21333 \cf0 \expnd0\expndtw0\kerning0
Copying Garbage Collection\
\pard\pardeftab720\partightenfactor0

\b0\fs32 \cf0 At an abstract level, all a 
\i copying
\i0  
\i collector
\i0  does is start from a set of roots (in our case, the operand stack), and traverse all of the reachable memory-allocated objects, copying them from one half of memory into the other half. The area of memory that we copy from is called 
\b old space
\b0  and the area of memory that we copy to is called 
\b new space
\b0 . When we copy the reachable data, we 
\b compact
\b0  it so that it is in a contiguous chunk. So, in effect, we squeeze out the holes in memory that the garbage data occupied. After the copy and compaction, we end up with a compacted copy of the data in new space data and a (hopefully) large, contiguous area of memory in new space in which we can quickly and easily allocate new objects. The next time we do garbage collection, the roles of old space and new space will be reversed.}